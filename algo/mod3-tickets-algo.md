
# DFS
## 1.(b) Эйлеров цикл. Эйлеров путь. Случай ориентированного и неориентированного графа.Поиск за O(V + E). Ленивое удаление рёбер.

### Термины
- **Th** - Связный неорграф эйлеров iff все степени вершин чётны.

### Код 
```cpp
vector <set <int >> g; // наивный способ хранения, удобно удалять рёбра void dfs( int v ) {
while (!g[v].empty()) { // единственное изменение кода
	int x = *g[v].begin();
	g[v].erase(x), g[x].erase(v);
	dfs ( x ) ; // dfs(x) найдёт цикл одной из компонент и вставит ровно сюда
	answer.push_front(edge(v, x)); }
}
```
- Так работает долго, можно сделать структуру **Edges** - тогда будет линия.(ребра удаляем лениво).


## 2.(b) Раскраска вершин графа в k цветов. Сложность задачи для разных k.Жадное решение за O(V + E).

### Определения
- **Задача вершинной покарски** - раскрасить вершины графа так, чтобы смежные были разных цветов.
  
###  Тезисы

- **2 цвета** - умеем за **O(V + E)** - *dfs*.
- **Более 2ух** - не умеем быстро - **NP-задача**, только жадно умеем искать примерный ответ.
  
### Жадный алгоритм
- Берём вершину минимальной степени, удаляем её из графа. Красим всё кроме неё, и в конце докрашиваем её в минимально возможный цвет. **Время работы** - O(V + E).


## 3.(a) Мосты и точки сочленения. Тривиальный алгоритм за O(VE)

### Алгоритм за 𝒪(𝑉𝐸)
- заметим, что любой мост лежит в остовном дереве ⇒ dfs-ом найдём любой остов, каждое ребро остова проверим за 𝒪(𝐸).


## 4.(b) Мосты и точки сочленения. Алгоритм за O(V + E) без доказательства корректности.

### См. билет 6.



## 5.(b) Двусвязность: вершинная и рёберная. Два определения: через удаление объектов, через отношение эквивалентности.

### См. билет 7.





## 6.(c) Мосты и точки сочленения, сильная связность. Доказательство корректности линейных алгоритмов.
### Алгоритм за O(V + E)
- Найдем остов через *dfs*
- Если из поддерева текущей вершины нельзя попасть *наверх*, минуя ребро, то такое ребро - **мост**.
- Для этих целей делаем ДП по дереву - самая высокая вершина, которую можно достигнуть из 𝑥, если запрещено ходить по ребру.

### Уточнение
- Алгоритм для точек сочленения почти идентичен поиску мостов. Идея та же: если мы из точки сочленения 𝑣 пошли вглубь по ребру 𝑒: 𝑣 → 𝑥, подняться выше, не проходя через 𝑣, мы не сможем ⇒ min_time[x] >= time[v]
  

### Код
```cpp
void dfs(int v, int parent):
	stack.push(v) // чтобы восстановить компоненты двусвязности 
	time[v] = ++T // время входа (а можно использовать высоту)
	min_time[v] = ++T; // наша динамика по дереву
	for (int x : adjacent[v])
		if (x != parent) { // если бы в графе были кратные рёбра, проверка была бы сложнее
		if (time[x] == 0) { // ещё не ходили в 𝑥 ⇒ идём и делаем ребро древесным
			int stack_level = stack.size(); // уровень стека до рекурсивного вызова dfs(x, v);
			if (min_time[x] > time[v]) { // мост!
				vector<int> component;
				while (stack.size() > stack_level) component.push(stack.pop())
			}
			relaxMin(min_time[v], min_time[x]);
		} else { // обратное или прямое ребро (𝑥 или предок, или потомок 𝑣 в дереве)
			relaxMin(min_time[v], time[x]);
		
		} 
	}


```

### Доказательство корректности
- Нужно доказать, что мы нашли мосты и только их.
  Если ребро 𝑒: 𝑣 → 𝑥 мост, то из 𝑥 нельзя достичь 𝑣 ⇒ min_time[x] > time[v] ⇒ наш алгоритм корректно поймёт, что 𝑒 — мост.
- Если 𝑒: 𝑣 → 𝑥 не мост, то есть путь 𝑝 из 𝑥 в 𝑣 в обход 𝑒. Поскольку мы используем именно dfs, кроме древесных и прямых рёбер есть только обратные и только они могут вести из поддерева 𝑥 наружу, причём вести они могут только в вершины 𝑧 ∈ пути 𝑟𝑜𝑜𝑡 ⇝ 𝑣. Осталось заметить, что 𝑚𝑖𝑛_𝑡𝑖𝑚𝑒[𝑥] ⩽ 𝑡𝑖𝑚𝑒[𝑧] ⩽ 𝑡𝑖𝑚𝑒[𝑣] ⇒ наш алгоритм корректно поймёт, что 𝑒 — не мост.

## 7.(c) Двусвязность: вершинная и рёберная. Алгоритм со стеком поиска компонент за O(V +E)

### Определения
- **Вершинная двусвязность** - есть вершинно простой цикл, содержащий оба ребра.
-  **Вершинная двусвязность** - отношение эквивалентности на _рёбрах_ неорграфа.
- **Реберная двусвязность** - между ними есть два рёберно не пересекающихся пути.
- **Реберная двусвязность** - отношение эквивалентности на _вершинах_ неорграфа. Классы эквивалентности – компоненты рёберной двусвязности.

### Алгоритм поиска компонент за O(V + E)

- По сути, алгоритм аналогичен описанному в билете 6.
- **Ключевая идея:** Если из точки сочменения \( v \) пошли вглубь по ребру \( e: v \rightarrow x \), то подняться выше, не проходя через \( v \), невозможно. Это выражается условием:
  \[
  \text{min\_time}[x] \geq \text{time}[v]
  \]
- **Критерий новой компоненты:** Если неравенство строгое (\( \text{min\_time}[x] > \text{time}[v] \)), то ребро \( e \) является мостом.

###  Нюансы
- Если \( \text{min\_time}[x] \geq \text{time}[v] \), то вершина \( v \) является точкой сочленения.
- Для неориентированного графа каждое ребро обрабатывается дважды.
- Вершина \( v \) — точка сочленения, если на ней смыкаются хотя бы две компоненты:
  - Одна компонента уже найдена.
  - Вторая может быть выше (если \( v \) — не корень) или ниже (если \( \text{count} \geq 2 \)).

### Код
```cpp
void dfs(int v, int parent) {
    time[v] = min_time[v] = ++T;
    int count = 0; // Количество компонент, цепляющихся за вершину v

    for (int x : adjacent[v]) {
        if (x != parent) {
            int stack_level = stack.size();

            // Для неориентированного графа каждое ребро обрабатывается дважды
            if (ещё не ходили по ребру {x, v}) {
                stack.push({v, x});
            }

            if (time[x] == 0) { // Если вершина x ещё не посещена
                dfs(x, v);

                if (min_time[x] >= time[v]) { // Новая компонента
                    vector<Edge> component;
                    while (stack.size() > stack_level) {
                        component.push_back(stack.pop());
                    }
                    // Обработка найденной компоненты
                }

                // Проверка на точку сочленения
                if (parent != -1 || ++count >= 2) {
                    points.push_back(v); // v — точка сочленения
                }

                relaxMin(min_time[v], min_time[x]);
            } else {
                relaxMin(min_time[v], time[x]);
            }
        }
    }
}
```

### Доказательство корректности
- Похоже на историю с мостами.
- Пусть мы шли в dfs 𝑝→𝑣→𝑥. Рёбра 𝑝→𝑣 и 𝑣→𝑥 лежат в одной компоненте iff есть путь 𝑥 → предок 𝑣 в дереве dfs ⇔ 𝑚𝑖𝑛_𝑡𝑖𝑚𝑒[𝑥] < 𝑡𝑖𝑚𝑒[𝑣].

## 8.(a) 2-SAT. Определение задачи. Решение за O(V E) методом «попробуем подставить».

### В пизду. Ботаем b-c.

## 9.(b) 2-SAT. Решение за O(V + E) без доказательства. Примеры задач: 2-LIST-COLORING, расположение геометрических объектов без наложений.
### См. билет 10.


## 10.(c)  2-SAT. Доказательство корректности решения за O(V + E).

### Определение
- **2-SAT** - нам дана КНФ формула 𝜙, в каждом клозе не более двух литералов. Нужно найти выполняющий набор 𝑥𝑖, или сказать, что 𝜙 противоречива.

### Примеры

- **2-LIST-COLORING** -  Дан неорграф граф, для каждой вершины 𝑣 есть список 𝑙[𝑣] из двух цветов.
	- Покрасить вершины так, чтобы соседние были покрашены в разные цвета.
	- Сведение: 𝑥𝑣 – номер выбранного цвета в 𝑙[𝑣], каждое ребро (𝑎, 𝑏) для каждого цвета 𝑐 ∈ 𝑙[𝑎]∩𝑙[𝑏] задаёт клоз ¬(𝑥_𝑎=𝑝𝑜𝑠_𝑎,𝑐 ∧ 𝑥_𝑏=𝑝𝑜𝑠_𝑏,𝑐) ⇔ (𝑥_𝑎=𝑝𝑜𝑠_𝑎,𝑐 ∨ 𝑥_𝑏=𝑝𝑜𝑠_𝑏,𝑐)
- **Расположение геометрических объектов без наложений.** - Есть множество отрезков на плоскости, каждому нужна подпись с одной из двух сторон отрезка.

### Нюансы
- Клоз (𝑎 ∨ 𝑏) ⇔ двум импликациям (¬𝑎 ⇒ 𝑏) и (¬𝑏 ⇒ 𝑎).
- Построим граф следствий. Вершины графа – литералы 𝑥_𝑖 и ¬𝑥_𝑖.
- Для каждого клоза (𝑎 ∨ 𝑏) проведём рёбра ¬𝑎 → 𝑏 и ¬𝑏 → 𝑎.
- Если 𝑛 – число неизвестных, 𝑚 – число клозов, мы получили 2𝑛 вершин и 2𝑚 рёбер.
- **Решение 2-SAT** – для каждого 𝑖 в графе следствий выбрать ровно одну из двух переменных 𝑥_𝑖, ¬𝑥_𝑖 так, чтобы не было рёбер из выбранных в невыбранные.
- ∃𝑖 : 𝑥_𝑖 и ¬𝑥_𝑖 в одной компоненте сильной связности ⇔ формула противоречива
- 
### Алгоритм решения за O(n + m)
- _Идейно_ - построить граф + найти ксс + вывести ответ.
- Топологически отсортируем конденсацию графа.
- 𝑘[𝑥_𝑖] – номер компоненты в топологическом порядке. ∀ ребра графа 𝑎 → 𝑏 верно 𝑘[𝑎] ⩽ 𝑘[𝑏].
- Для каждой переменной 𝑖 выберем 𝑥_𝑖 iff 𝑘[𝑥_𝑖] > 𝑘[¬𝑥_𝑖].

### Доказательство корректности
- Если в решение есть противоречие, то есть выбранный 𝑦, невыбранный 𝑧 и ребро 𝑦 → 𝑧. Рёбра добав- лялись парами ⇒ есть и ребро ¬𝑧 → ¬𝑦. 
- Из ∃ этих рёбер делаем вывод: 𝑘[𝑧] ⩾ 𝑘[𝑦] ∧ 𝑘[¬𝑦] ⩾ 𝑘[¬𝑧]. Из выбранности 𝑦, не выбранности 𝑧 вывод: 𝑘[𝑦] > 𝑘[¬𝑦] ∧ 𝑘[¬𝑧] > 𝑘[𝑧].


-------------------------------
-------------------------------
-------------------------------
# Сложности 
## 11.(a) Формулировки задач Halting Problem, k-CLIQUE, HAM-PATH, PRIME, IS-SORTED. В каких классах лежат?

### Термины
- NP = {𝐿: ∃𝑀, работающий за полином от |𝑥|, ∀𝑥(︀(∃𝑦𝑀(𝑥,𝑦) = 1) ⇔ (𝑥 ∈ 𝐿))︀}
- _Неформально_ - «NP – класс задач, ответ к которым можно проверить за полином». Подсказку 𝑦 так же называют свидетелем того, что 𝑥 лежит в 𝐿.
### Формулировка Halting Problem
- Дана программа, остановится ли она когда-нибудь на данном входе?
- Неразрешима

### Формулировка k-CLIQUE
- Проверить наличие в графе клики размером 𝑘. Подсказка 𝑦 – клика.
-  _Класс задачи_ NP

### Формулировка HAM-PATH
- {𝐺 | 𝐺 – неорграф, в котором есть гамильтонов путь}. Подсказка 𝑦 – путь.𝑀 получает вход 𝑥 = 𝐺, подсказку 𝑦, проверяет, что 𝑦 прост, |𝑦| = 𝑛 и ∀(𝑒∈𝑦) 𝑒∈𝐺.
- _Класс задачи_ NP

### Формулировка PRIME


### Формулировка IS-SORTED
- Отсортирован ли массив? Она даже лежит в 𝑃 .
- _Класс задачи_ NP
## 12.(a) Понятие языка, decision-задачи, search-задачи. Определения P, NP, EXP. Решение searchверсии через decision-версию. Формулировки задач: k-CLIQUE, MAX-CLIQUE.

### Термины
- **decision problem** - если в задаче ответ – true/false
- **search problem** - иначе.
- **P** - задачи, имеющие полиномиальное решение.
- **NP** - NP – класс задач, ответ к которым можно проверить за полином. Подсказку 𝑦 так же называют свидетелем того, что 𝑥 лежит в 𝐿.
- **EXP** -  задачи, имеющие экспоненциальное решение.


## 13.(b) Неконструктивное доказательство существования неразрешимых задач.

- _Доказательство_. От противного. Пусть есть алгоритм terminates(code,x), всегда останавливающийся, и возвращающий true iff code останавливается на входе x. Рассмотрим программу: 
	```cpp
	def invert(code):
		if terminates(code,code): while (true)
	```
	Если invert(invert) останавливается, то должен зависнуть, и наоборот. Противоречие.


## 15.(b)Неразрешимость Halting Problem.
СМ билет 14.


## 16.(c) Отмена билета!


## 17.(a)  Классы NP, NP-hard, NP-complete. Задача: пусть k-IND ∈ NPh, докажите, что k-CLIQUE ∈ NPc.
### Термины
- **NP** - было где-то выше.
- **NP-h** - класс задач, которые не проще любой задачи из класса NP.
- **NP-c** - NPc = NPh ∩ NP

## 18.(b) Полиномиальное сведение (по Карпу). Свойства полиномиального сведения.
- **Определение** - ∃ _полиномиальное сведение (по Карпу)_ задачи 𝐴 к задаче 𝐵: (𝐴⩽ 𝐵) ⇔ ∃ алгоритм 𝑓, работающий за полином, (𝑥 ∈ 𝐴) ⇔ (𝑓(𝑥) ∈ 𝐵)
- _Неформально_ - Ещё говорят «задача 𝐴 сводится к задаче 𝐵». Мы решаем задачу 𝐴, используя уже готовое решение задачи 𝐵. Т.е. доказываем, что «𝐴 не сложнее 𝐵».

## 19.(b) Доказательство существования NP-полных задач. BH ∈ NPc.
- **BOUNDED-HALTING** - вход 𝑥 = ⟨11. . .1, 𝑀, 𝑥⟩, проверить, ∃ ли такой 𝑦 : 𝑀(𝑥,𝑦) остановится за 𝑘 шагов и вернёт true.
- **Доказательство** - _BH $\in NPc$_.
	- Программа 𝑀 всегда отрабатывает за 𝑃(|𝑥|), если запустить её с будильником 𝑃(|𝑥|), она не поменяется. Рассмотрим 𝑓(𝑥) = ⟨11...1,𝑀,𝑥⟩.
	- Получили полиномиальное сведение: (𝑥 ∈ 𝐿) ⇔ (∃𝑦 𝑀 (𝑥, 𝑦) = 1) ⇔ (𝑓 (𝑥) ∈ BH).



## 20.(b)  Сведения BH → CIRCUIT-SAT → SAT → 3-SAT. Что следует из этих сведений?
### Определение
- _CIRCUIT-SAT_ -  Дана схема, состоящая из входов, выхода, гейтов AND, OR, NOT. Проверить, существует ли набор значений на входах, дающий true на выходе.
  
### Сведения
1. $BH →  CIRCUIT-SAT$
   - Подсказка – набор значений на входах ⇒ CIRCUIT-SAT ∈ NP
   - Обозначим за $ s_{𝑖,𝑗} $ состояние true/false 𝑗-й ячейки памяти в момент времени 𝑖. $𝑠_{0,𝑗}$ – вход, $s_{𝑡,𝑜𝑢𝑡𝑝𝑢𝑡}$ – выход, ∀𝑖 ∈ [1, 𝑡] $𝑠_{𝑖,𝑗}$ зависит от 𝒪(1) переменных (𝑖−1)-го слоя.
   - Сейчас значение $s_{i,j}$ – произвольная булева формула $f_{i,j}$ от 𝒪(1) переменных из слоя $s_{𝑖−1}$.
   - Перепишем в форме КНФ. Построили вход к _CIRCUIT-SAT_. Победа.
2. $CIRCUIT-SAT → SAT$
   - каждому узлу соответствует формула $𝑣_𝑖 = 𝑓_𝑖(𝑣_𝑗,𝑣_𝑘)$.
   - Это булева формула от трех переменных, запишем ее в КНФ. Соединим все КНФ вмест
3. $SAT → 3-SAT$
   - Пусть есть клоз $(𝑥_1 ∨ 𝑥_2 ∨ · · · ∨ 𝑥_𝑛), 𝑛 ⩾ 4$.
   - Введём новую переменную 𝑤 и заменим его на $(𝑥_1 ∨ 𝑥_2 ∨ 𝑤)∧(𝑥_3 ∨···∨𝑥_𝑛 ∨ \neg 𝑤)$

## 21.(b)  Сведения 3-SAT → k-IND → k-CLIQUE → VERTEX-COVER. Что следует из этих сведений?
### Определения
- _k-IND_ - есть ли в графе независимое подмножество размера 𝑘?
- _k-CLIQUE_ - есть ли в графе полное подмножество вершин размера 𝑘?
- _VERTEX-COVER_ - существует ли вершинно покрытие
### Сведения
1. $3-SAT → k-IND$
   - Наша формула – 𝑚 клозов $(𝑙_{𝑖1} ∨ 𝑙_{𝑖2} ∨ 𝑙_{𝑖3})$, где $𝑙_{𝑖𝑗}$ – литералы
   - Построим граф из ровно 3𝑚 вершин.
   - ∀𝑖 добавим треугольник $(𝑙_{𝑖1} ∨ 𝑙_{𝑖2} ∨ 𝑙_{𝑖3})$.
   - В любое независимое множество входит максимум одна вершина из каждого треугольника.
   - ∀𝑘 = 1..𝑛 соединим все вершины $𝑙_{𝑖𝑗}$  = $𝑥_𝑘$ со всеми вершинами $𝑙_{𝑖𝑗}$  = $𝑥_𝑘$. Теперь их нельзя одновременно включить в ответ.
	- Построили полиномиальное сведение.
2. $k-IND → k-CLIQUE$
   - Клика в графе G — это независимое множество в его дополнении $\neg G$, и наоборот.
   - $𝑐_{𝑖𝑗} $– есть ли ребро между 𝑖 и 𝑗 вершинами. Создадим новый граф: $𝑐`_{𝑖𝑗}  = 𝑐_{𝑖𝑗} ∧ (𝑖 \neq 𝑗)$
3. $k-CLIQUE → VERTEX-COVER$
   - Построим дополнение графа.
   - Теперь задача k-CLIQUE для графа эквивалентна задаче VERTEX-COVER для графа-дополнения.
 
## 22.(a) Примеры задач из NP, про которые считается, что они не в P ∪ NPc ∪ coNPc.

- **Факторизация целых чисел** - проверка корректности решения выполняется за полиномиальное время, но эффективного алгоритма для самой факторизации не известно. При этом она не является NP-полной, так как её NP-полнота привела бы к коллапсу NP = coNP(умеем и непринадлежность проверять за полином)
- **Изоморфизм графов** - Если дать сертификат (перестановку вершин), изоморфизм проверяется за полиномиальное время. Нет быстрого полиномиального алгоритма.


## 23.(b) Решение search-задач минимизации/максимизации через decision-версию. Решение searchверсий SAT и k-INDEPENDENT-SET через decision-версии. Использование SAT-солверов.



## 24.(b) Гипотезы ETH, SETH. Формулировки. Следствия между 3 гипотезами.

## 25.(c) coNP, coNEXP

## 26.(a) Классы RP, coRP, связь с классами P, NP
### Опеределение
- **PR** - «решающие decision задачи, работающие всегда за полином, ошибающиеся в одну сторону»
- **coPR** - это класс задач, для которых существует вероятностный алгоритм, который если ответ «нет», то алгоритм с высокой вероятностью (не менее 50%) скажет «нет», если ответ «да» , то алгоритм всегда скажет «да».

### Сравнение классов NP, RP
- Если ответ 0, оба алгоритма для ∀ подсказки выдадут 0. Если ответ 1, для NP-алгоритма ∃ хотя бы одна подсказка, а RP-алгоритм должен корректно работать хотя бы на половине подсказок.



## 27.(b) Понижение ошибки в RP, coRP.
- Запустим PR/coPR алгоритм 𝑘 раз, если хотя бы раз вернул 1, вернём 1. Получили алгоритм с ошибкой $p^k$.


## 28.(a) Задачи: самый частый элемент, $3-LIST-COLORING$, matrix multiplication testing.
- _Часто встречающееся число_ - Поиск числа, которое встречается в массиве больше половины раз
	- «хотим определить, есть ли такой элемент в массиве, делаем одну пробу»
- _3-LIST-COLORING_ - вычеркнуть из каждого клоза случайный элемент, получить 2-SAT. Вероятность успеха этого алгоритма 2𝑛 , чтобы получить вероятность 1/2 , нужно было бы повторить его $1.5^𝑛 \ln 2$ раз, поэтому к RP-алгоритмам он не относится.
- _matrix multiplication testing_ - 

## 29.(b) Тест Ферма, тест Миллера-Рабина
- **Тест Ферма** - Чтобы проверить простоту 𝑝, можно взять случайное 𝑎 и проверить a^{p - 1} \equiv 1
- ∃𝑎: a^{p - 1} \equiv 1 ⇒ таких 𝑎 хотя бы $(p - 1) / 2$
- У числа Кармайкла 𝑎 есть простой делитель не более $a^{1/3}$.
- **Тест Миллера-Рабина** - проверим возможные делители от 2 до$a^{1/3}$(на числа _кармайкла_), далее тест Ферма.

## 30.(b) Парадокс дней рождений, анализ вероятности в две стороны
- **Формулировка** - Если n объектов равномерно случайно размещают по M корзинам, где $n \geq \sqrt m$, то с вероятностью $\frac{1}{2}$ какие-то $2$ объекта попадут в одну корзину.

### Обозначения:
- \( n \) — количество возможных дней (например, 365).
- \( p_k \) — вероятность того, что все \( k \) дней рождения различны.
- \( 1 - p_k \) — вероятность хотя бы одного совпадения.
  
### Точная оценка для \( k = \sqrt{n} \)
\[ 0.46 \leq p_k \leq 0.8 \]
**Доказательство:**
1. Выразим \( p_k \) через произведение:
   \[
   p_k = \prod_{i=0}^{k-1} \left(1 - \frac{i}{n}\right)
   \]
2. Для \( k = \sqrt{n} \), разобьём произведение на две части:
   \[
   p_k = \underbrace{\prod_{i=0}^{\sqrt{n}/2} \left(1 - \frac{i}{n}\right)}_{\text{первая половина}} \cdot \underbrace{\prod_{i=\sqrt{n}/2+1}^{\sqrt{n}} \left(1 - \frac{i}{n}\right)}_{\text{вторая половина}}
   \]
3. Используем приближение \( \ln(1 - x) \approx -x \) для малых \( x \):
   \[
   \ln p_k \approx -\sum_{i=0}^{k-1} \frac{i}{n} = -\frac{k(k-1)}{2n}
   \]
4. При \( k = \sqrt{n} \):
   \[
   p_k \approx e^{-\frac{k^2}{2n}} = e^{-0.5} \approx 0.606
   \]
   Уточняя оценки границ:
   - Верхняя граница: \( p_k \leq e^{-1/4} \approx 0.778 \)
   - Нижняя граница: \( p_k \geq e^{-1/4} \cdot e^{-1/2} \approx 0.472 \)

## Билет 31.(a) Алгоритм Полларда за $O(n^{1/4} log n)$ арифметических операций. Без обоснований.
Похуй, ботаем b,c.

## Билет 32. Алгоритм Полларда за $O(n^{1/4})$ арифметических операций. Обоснование.
### Формулировка
- **Поллард** - рандомизированный алгоритм факторизации целых чисел и основывающийся на следствии из парадокса дней рождений:
  - В мультимножество нужно добавить $O(\sqrt n)$ случайных чисел от 1 до n, чтобы какие-то два совпали.
```cpp
b = a = random 
while True:
	a = f(a)
	b = f(f(b))
	if gcd(a - b, n) != 1: // нашли делитель

```
- Обоснование - Можно считать gcd не на каждом шаге, а сразу посчитать gcd от ∏︀(𝑎𝑖 − 𝑏𝑖), взять в произведение ⩾ log 𝑛 разностей.

## Билет 33.(b) Решение 3-SAT. Детерминированный и рандомизированный алгоритмы за $1.73^n$ (с доказательствами).
**Детерменированный алгоритм** - Пусть решение 𝑋 * существует и в нём нулей больше чем единиц. Начнём с 𝑋0 = {0, 0, . . . , 0},
чтобы из 𝑋0 попасть в 𝑋* нужно сделать не более 𝑛 шагов. Если 𝑋𝑖 не решение, то какой-то 2
𝑖
клоз не выполнен, значит в 𝑋* одна из трёх переменных этого клоза имеет другое значение. Переберём, какая. Получили рекурсивный перебор глубины 𝑛 , с ветвлением 3. Если в 𝑋 * единиц
2
больше, начинать нужно с 𝑋0 = {1, 1, . . . , 1}. Нужно перебрать оба варианта.

**Рандомизированный** - начнём со случайного 𝑋0, с вероятностью 1 он на расстоянии
2
6 1𝑛 от ответа. Сделаем 1𝑛 шагов, выбирая каждый раз случайное из трёх направлений. На 22
каждом шаге с вероятностью 1 мы приближаемся к ответу. Итого с вероятностью 1 · 1 мы 3 2 3𝑛/2
придём в ответ. Повторим 𝒪(3𝑛/2) ≈ 𝒪(1.73𝑛) раз.
## Билет 34.(c) Решение 3-SAT. Рандомизированные алгоритмы за $1.5^n$ и $1.34^n$ (с доказательствами).
**Улучшенный рандом** - Почти такой же алгоритм. Сделаем теперь не 𝑛 , а 𝑛 шагов. 2
В процессе доказательства нам пригодится знание ∀𝛼 ∑︀ ((︀𝑛)︀𝛼𝑘) = (1 + 𝛼)𝑛.
Доказательство: раскроем скобочки.
Анализ вероятностей. Если перебор за 3𝑛/2 перебирал все варианты, то мы перебираем 1 вариант
и угадываем с вероятностью > 𝑝 = ∑︀ 𝑃𝑟[𝑘] 1 , где 𝑘 – расстояние Хэмминга от 𝑋 до 𝑋*, а (︀𝑛)︀𝑛 𝑘 3𝑘 0
𝑃 𝑟[𝑘] = /2 – вероятность того, что при выборе случайного 𝑋0 расстояние равно 𝑘. 𝑝=∑︀ 1𝑘(︀𝑛)︀1 = 1 (1+1)𝑛 =(2)𝑛 ⇒повторимпроцесс1.5𝑛 раз.
𝑘2𝑛𝑘3𝑘 2𝑛 3 3
Кстати, поскольку 𝑃 𝑟[𝑘 6 𝑛 ] = 1 , достаточно делать даже не 𝑛, а 𝑛 шагов.
222
**Улучшенный рандом 2.0** - Schoning’s algorithm (1999). Получается из предыдущего решения заменой 𝑛 шагов на 3𝑛 шагов.
2
Вероятность успеха будет не менее (3/4)𝑛 ⇒ время работы 𝒪*(1.334𝑛).

## Билет 35.(c) Решение 3-SAT. Приближённые алгоритмы для MAX-3-SAT в общем случае, и в случае, когда в каждом клозе ровно 3 литерала
**Детерменированный** - 
Возьмём произвольные значения переменных, если выполнено меньше 𝑚/2 клозов, инвертируем все переменные. Итого: мы выполнили ⩾ 𝑚/2 ⩾ 1/2  OPT клозов.

**Рандомизированный** - Подставим все переменные случайно.
Если в клозе $k$ литералов, то он выполнился с вероятностью $𝑃𝑟 = (1−2^{−𝑘}) $. Так как $k \geq 1 \Rightarrow Pr \geq \frac{1}{2}$.
Знаем, что *Максимизировать число выполненных клозов ⇔ минимизировать число нарушенных*.
Если отклонились от 𝑋 менее, чем на $1/2$, то из-за целочисленности попали в 𝑋.
$1/2 m + 1/2 = 1/2 𝑚(1 + 1/m )$. Пользуемся понижением вероятности для $\epsilon = 1/m$ ,итого нужно $m + 1$ запусков.

## Билет 36.(a) Лемма Шварца-Зиппеля без доказательства.
### Похуй ботаем b - c

## Билет 37.(c) Лемма Шварца-Зиппеля: доказательство.
**Формулировка** - Пусть дан многочлен $\mathbb{𝑃}$ от нескольких переменных над полем $\mathbb{F}$.
\[ (p \not\equiv 0) \Rightarrow Pr_x[P(x) = 0] \leqslant \frac{deg P}{| \mathbb{F}|}\]
   
**Доказательство** - Индукция по числу переменных.
_База_ -  многочлен от 1 переменной имеет не более deg 𝑃 корней.
_Переход_ - 

## Билет 38.(a) Класс BPP. Понижение ошибки без доказательства.
**Определение** _BPP_ - алгоритм всегда даёт корректный ответ с вероятностью хотя бы 2/3.

**Lm. О понижении ошибки.** -  Пусть $ 𝛽 > 0, 𝛼 = 1/2 + 𝜀, 𝜀 > 0 ⇒ ∃𝑛 = 𝑝𝑜𝑙𝑦(1/𝜀 )$ такое, что
повторив алгоритм 𝑛 раз, и вернув majority, мы получим вероятность ошибки не более 𝛽


## Билет 39.(b) Класс ZPP. Теорема ZPP = RP ∩ coRP.
**Определение** _ZPP_ - класс задач, для которых есть никогда не ошибающийся вероятностный алгоритм с
полиномиальным матожиданием временем работы.

**ZPP = RP ∩ coRP**
_Доказательство_: 

## Билет 40.(b)  Связь между классами P, NP, RP, coRP, ZPP, BPP. Три открытых вопроса.
**P⊆coRP∩RP=ZPP⊆RP⊆NP**
При этом строгие ли вложения неизвестно (про все три вложения).


## Билет 41.(a) . Идеальное шифрование. Вычисление средней зарплаты без разглашения.


## Билет 42.(b) Random shuffle массива. Игра на 0-1-дереве, min-max-игра на дереве.

-------------------------------
-------------------------------
-------------------------------
# Графы





-------------------------------
-------------------------------
-------------------------------
# Жадность


-------------------------------
-------------------------------
-------------------------------
# Центроиды

## 95.(a) Центроидная декомпозиция: построение за O(n log n) времени, O(n) памяти
### см. билет 96

## 96.(b) Подробности хранения, LCA, поиск минимума на пути за O(log n) и O(log log n), поиск gcd на отрезке массива

### Термины
- **Центроид** – вершина, при удалении которой, размеры всех компонент ⩽ 𝑛 
- **Центроидной декомпозицией** будем называть два массива – 𝑝𝑣 и 𝑑𝑣. Первый из массивов задаёт так называемое “дерево центроидной декомпозиции”.
- Для центроидной декомпозиции нужно Θ(𝑛) памяти.
-  Глубина дерева центроидной декомпозиции не более log 𝑛.
-  Суммарный размер компонент 𝒪(𝑛 log 𝑛)

### Алгоритм построения
- Рекурсивный процесс «выделить центроид, удалить, запуститься от компонент».
- Запускаем dfs от каждой вершины, чтобы найти длину поддерева.
- Далее спускаемся из начальной вершины в ребёнка с максимальным размером до тех пор, пока его размер ≥n/2 
- Тем самым нашли минимальный центроид
- После этого запоминаем порядок вершины. Затем запускаемся dfs-ом от этой вершины и заполняем P[a][0] для всех a.
- Для поиска центроидов следующего порядка запускаемся рекурсивно поиском центроида от каждого из детей центроида предыдущего порядка. Делаем всё тоже самое,  но не входим в те вершины, порядок которых мы уже узнали

### Gcd на отрезке
#### Формулировка 
- Дан массив целых чисел от 1 до 𝐶. Массив не меняется.Научитесь в online отвечать на запросы «gcd на отрезке [𝐿,𝑅]» за 𝒪(log𝐶).
#### Решение
- Массив – это дерево. Можно на нем строить Centroid Decomposition. Получится Disjoint Sparse Table. Дальше считать gcd[𝑣, 𝑑] и отвечать на запросы, как обычно: по 𝑣, 𝑢 находить 𝑥: 𝑢,𝑣 ∈ 𝐶(𝑥)∧𝑥 ∈ path(𝑢,𝑣), отвечать gcd(gcd[𝑢,𝑑𝑥],gcd[𝑣,𝑑𝑥]). Можно даже за 𝒪(loglog𝑛+ log𝐶).

### Поиск минимума на пути за O(log n) и O(log log n)
#### Формулировка 
- Найти минимум на пути [a, b]
#### Решение-1.
- Очев, что для любого пути [𝑎..𝑏] на дереве, есть такой центр 𝑣: 𝑣 ∈ 𝑝𝑎𝑡h[𝑎..𝑏] и 𝑎,𝑏 ∈ 𝐶(𝑣).
- Чтобы найти такой центр 𝑣 рассмотрим пути от 𝑎 и 𝑏 вверх в дереве центроидной декомпозиции и возьмём наименьшего общего предка (LCA) 𝑎 и 𝑏 – самый нижний такой центр, что 𝑎, 𝑏 ∈ 𝐶_𝑣 .
- минимум на пути[𝑎..𝑏] = min(𝑓 [𝑑𝑣 , 𝑎], 𝑓 [𝑑𝑣 , 𝑏])
- LCA за 𝒪(глубины дерева). В нашем случае это 𝒪(log 𝑛)

#### Решение-2.
## 97.(b)  Disjoint Sparse Table
- **Определение:** Структура данных, позволяющая отвечать на запросы на отрезке (например, минимум, максимум, НОД) за \( O(1) \) после предобработки за \( O(n \log n) \).
- **Особенность:** Подходит для неассоциативных операций, где порядок применения операций важен.

### Алгоритм
1. **Предобработка:**
   - Разбиваем массив на блоки размера \( 2^k \).
   - Для каждого блока предвычисляем результаты операций на всех возможных подотрезках.
2. **Ответ на запрос:**
   - Находим блок, содержащий запрос, и объединяем результаты из предвычисленных таблиц.

## 98.(c) Количество путей длины d
### Решение: 
- Вмешаемся в процесс центроидной декомпозиции: для каждого центроида перед его удалением будем прибавлять к ответу число интересующих нас путей, которые проходят через этот центроид.
- Количество таких путей можно посчитать за размер текущей компоненты

## 99.(c) Покраска вершин на расстоянии ≤ d

### Решение 
- ?